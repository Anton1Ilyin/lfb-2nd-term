# Лабораторная 5
В прошлый раз вы научились писать инструкции для make - утилиты, которая умеет собирать многофайловый проект.
Наверное, вы заметили и то, что с увеличением количества файлов и усложнением зависимостей (которые надо отслеживать руками) писать инструкции становится все сложнее.
А еще бывает нужно добавить в проект системные библиотеки - само по себе несложно, но иногда их приходится искать в разных папках системы, и инструкции могут стать совсем громоздкими.

Другая бытовая проблема - у программистов на одном проекте могут оказаться разные среды разработки. 
А то и разные операционки.
Лучше, конечно, так не делать, но если уж случилось, хотелось бы иметь инструмент, который одинаковым образом генерирует инструкции для сборки - и Makefile, и файл проекта для Code::Blocks, и для Visual Studio. 

Самым распространенным на данный момент решением является **cmake**.
Давайте его и изучим.

## Что делаем
Продолжаем разбираться с системами сборки. 
Вначале посмотрим, что вообще такое библиотеки - какие они бывают, как их делать и как их подключать к вашему коду.
А потом уже будем погружаться в cmake (там не очень глубоко).

### 0. Флаги компиляции.
Как вы уже поняли, флаги - это модификаторы, которые мы задаем программе в командной строке.
В том числе и компилятору. 
У разных компиляторов флаги, вообще говоря, могут быть разные (хоть и похожие).
Мы рассматриваем g++.

Начнем с флага, которым вы уже пользовались, ```-o```. 
Он задает название итогового файла (output) и будет трактовать любое написанное следом слово как желаемое название.
Например, ```g++ -o hello hello.cpp``` или ```g++ hello.cpp -o hello``` - порядок не важен, но название остается "приклеенным" к флагу.

Следующий полезный флаг (точнее, несколько флагов) позволяет ускорять работу вашего кода практически без усилий с вашей стороны.
Флаги ```-O0```, ```-O1```, ```-O2```, ```-O3``` включают разные уровни оптимизации:
- ```-O0``` без оптимизации, вариант по умолчанию;
- ```-O1``` немного подрезает инструкции, приоритезируя размер бинарника;
- ```-O2``` сильно ускоряет код, местами переделывает логику, но гарантированно ничего не ломает (если сам код написан корректно);
- ```-O3``` добавляет к предыдущему варианту некоторые агрессивные оптимизации, которые могут испортить точность, поэтому в научных расчетах с ним надо быть осторожно;
- ```-Ofast``` будет еще быстрее, но может сильно поломать точность - для игр ок, для научных расчетов не ок.
Важный момент насчет оптимизации. 
Если ваш код "ну чучуть" некорректен - например, вылезает на несколько байтов в сторону от массива в куче - оптимизация может его "сломать".
*В кавычках, потому что вообще-то код и был сломан, просто под О0 вы этого не замечали - например, там было не очень эффективное распределение памяти и зазоры между данными, вы попадали в них, и все типа работало, а вот более эффективное распределение памяти или перестановка переменных местами вам уже ничего не простили.*

*Для начала, чтобы начать работать с оптимизациями, такого описания вам будет достаточно.
Подробнее про то, как оно устроено, будет в следующем семестре про ассемблер, потому что без рассматриваемых там терминов, концепций и инструментов любой разговор про оптимизацию превращается в странную магию.
А там оно будет довольно просто и понятно.*

Флаг ```-g```, очень полезный при отладке, добавляет дебаговые символы.
Они позволяют отслеживать команды в бинарнике обратно до строк кода С++ и изображать, что они исполняют по очереди строки кода на С++.
А еще они позволяют valgrind говорить вам, в какой именно строчке кода произошла ошибка.
Учтите, что этот флаг работает только с О0 - любая оптимизация необратимо перекраивает код, и обратно в строки плюсов вернуться уже не получается.

Флаги стандартов: например ```-std=c++17```включает 17 стандарт.
У разных механик С++ и методов/классов STL может быть разное время жизни с точки зрения стандартов.
Например, одна функция может быть введена в с++03 и удалена в с++17 (см. <https://en.cppreference.com/w/cpp/memory/auto_ptr>).
Время жизни лучше проверять по cppreference, там вполне актуальная информация (можно даже посмотреть, есть в вашем компиляторе конкретная механика из стандарта <https://en.cppreference.com/w/cpp/compiler_support>, свою версию можно посмотреть так: ```g++ -v```).

Это были флаги, которые вам сейчас нужнее всего. 
Есть те, которые нужны поменьше - например, переключать уровень предупреждений (warnings).
Их можете погуглить.
Есть специализированные, типа указания путей или библиотек, их мы рассмотрим в следующих пунктах.

Проверьте все эти флаги на несчастном yet_another_educational_cowsay.
Скорость работы можете смотреть утилитой time, про нее можете почитать в прошлой лабе (пункт #7).

### 1. Статические библиотеки.

### 2. Динамические библиотеки.

### 3. Немного кругозора.
Посмотрите на разные проектные файлы. 
Они служат той же цели, что и Makefile - хранят инструкции, по которым исполняемый файл будет генериться из исходников.

Попробуйте найти аналогичные инструкции в файлах проектов - каких-то своих или из папки 00\_project\_files.
Если вы на постоянной основе пользуетесь какой-либо средой разработки, обязательно найдите, как эти инструкции выглядят в оконно-кнопочном интерфейсе.
Пригодится.

Где-то в них написано, какой будет компилятор.
Например, у вас может быть установлен gcc, clang, icc (компилятор от Intel) и MSVC (компилятор от Microsoft).
В настройках проекта вы можете выбирать, каким именно компилятором вы хотите компилировать именно этот конкретный проект. 
*Может быть, это вообще будет компилятор не для С++, а для Fortran или Pascal.
Это компилируемые языки, и в них тоже могут быть многофайловые проекты.*
В Makefile вы писали его каждый раз вручную или создавали переменную (например, CXX\_COMPILER).

В файлах проектов могут быть указаны дополнительные пути к библиотекам, статическим и динамическим. 
Попробуйте найти их. 

Какие именно библиотеки подключать - тоже в этих инструкциях. 

И последнее важное, что надо найти - флаги компилятора.
Оптимизация, переключение стандартов, дебаговые символы - все из пункта 0. 
**Вот флаги особенно важно найти в вашей среде разработки.**

### 4. Базовый cmake.

### 5. Подключение библиотек в cmake.

### 5. Рекурсивный cmake.

## Что сдаем

## Материалы
