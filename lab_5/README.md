# Лабораторная 5
В прошлый раз вы научились писать инструкции для make - утилиты, которая умеет собирать многофайловый проект.
Наверное, вы заметили и то, что с увеличением количества файлов и усложнением зависимостей (которые надо отслеживать руками) писать инструкции становится все сложнее.
А еще бывает, что нужно добавить в проект системные библиотеки - само по себе несложно, но иногда их приходится искать в разных папках системы, и инструкции могут стать совсем громоздкими.

Другая бытовая проблема - у программистов на одном проекте могут оказаться разные среды разработки. 
А то и разные операционки.
Лучше, конечно, так не делать, но если уж случилось, хотелось бы иметь инструмент, который одинаковым образом генерирует инструкции для сборки - и Makefile, и файл проекта для Code::Blocks, и для Visual Studio. 

Самым распространенным на данный момент решением является **cmake**.
Давайте его и изучим.

## Что делаем
Продолжаем разбираться с системами сборки. 
Вначале посмотрим, что вообще такое библиотеки - какие они бывают, как их делать и как их подключать к вашему коду.
А потом уже будем погружаться в cmake (там не очень глубоко).

### 0. Флаги компиляции.
Как вы уже поняли, флаги - это модификаторы, которые мы задаем программе в командной строке.
В том числе и компилятору. 
У разных компиляторов флаги, вообще говоря, могут быть разные (хоть и похожие).
Мы рассматриваем g++.

Начнем с флага, которым вы уже пользовались - ```-o```. 
Он задает название итогового файла (output) и будет трактовать как название любое написанное следом слово.
Например, ```g++ -o hello hello.cpp``` или ```g++ hello.cpp -o hello``` - порядок флагов не важен, но название остается "приклеенным" к флагу как его "аргумент".

Следующий полезный флаг (точнее, несколько флагов) позволяет ускорять работу вашего кода практически без усилий с вашей стороны.
Флаги ```-O0```, ```-O1```, ```-O2```, ```-O3``` включают разные уровни оптимизации:
- ```-O0``` без оптимизации, вариант по умолчанию;
- ```-O1``` немного подрезает инструкции, приоритизируя размер бинарника;
- ```-O2``` сильно ускоряет код, местами переделывает логику, но гарантированно ничего не ломает (если сам код написан корректно);
- ```-O3``` добавляет к предыдущему варианту некоторые агрессивные оптимизации, которые могут испортить точность, поэтому в научных расчетах с ним надо быть осторожно;
- ```-Ofast``` будет еще быстрее, но может сильно поломать точность - для игр ок, для научных расчетов не ок.
Важный момент насчет оптимизации. 
Если ваш код "ну чучуть" некорректен - например, вылезает на несколько байтов в сторону от массива в куче - оптимизация может его "сломать".
*В кавычках, потому что вообще-то код и был сломан, просто под О0 вы этого не замечали - например, там было не очень эффективное распределение памяти и зазоры между данными, вы попадали в них, и все типа работало, а вот более эффективное распределение памяти или перестановка переменных местами вам уже ничего не простили.*

*Для начала, чтобы начать работать с оптимизациями, такого описания вам будет достаточно.
Подробнее про то, как оно устроено, будет в следующем семестре про ассемблер, потому что без рассматриваемых там терминов, концепций и инструментов любой разговор про оптимизацию превращается в странную магию.
С ассемблером оно будет довольно просто и понятно.*

Флаг ```-g```, очень полезный при отладке, добавляет дебаговые символы.
Они позволяют отслеживать команды в бинарнике обратно до строк кода С++.
Например, встроенный в среду разработки дебаггер может с их помощью изображать, что он исполняет по очереди строки кода на С++.
А еще они позволяют valgrind говорить вам, в какой именно строчке кода произошла ошибка.
Учтите, что этот флаг работает только с О0 - любая оптимизация необратимо перекраивает код, и обратно в строки плюсов вернуться уже не получается.

Флаги стандартов: например ```-std=c++17```включает 17 стандарт.
У разных механик С++ и сущностей из STL может быть разное время жизни с точки зрения стандартов.
Например, одна функция может быть введена в с++03 и удалена в с++17 (см. <https://en.cppreference.com/w/cpp/memory/auto_ptr>).
Время жизни лучше проверять по cppreference, там вполне актуальная информация (можно даже посмотреть, есть ли в вашем компиляторе конкретная механика из стандарта <https://en.cppreference.com/w/cpp/compiler_support>, свою версию можно посмотреть так: ```g++ -v```).

Это были флаги, которые вам сейчас нужнее всего. 
Есть те, которые нужны поменьше - например, переключать уровень предупреждений (warnings).
Их можете погуглить.
Есть специализированные, типа указания путей или библиотек, их мы рассмотрим в следующих пунктах.

Проверьте все эти флаги на несчастном yet_another_educational_cowsay.
Скорость работы можете смотреть утилитой time, про нее можете почитать в прошлой лабе (пункт #7).

### 1. Статические библиотеки.
После этапа компиляции многофайлового проекта вы получаете набор объектных файлов.
Иногда вы понимаете, что часть этих файлов можно сгруппировать в некоторую единую сущность - она редко перекомпилируется, большая часть кода использует только друг друга, а внешний код вызывает только несколько функций. 
Так появились системные библиотеки и стандартная библиотека STL - это уже кем-то написанный и заранее скомпилированный код, который вы можете подключить к своему.

Давайте разберемся, как это делается технически, и какие есть варианты.

Первый вариант, самый простой - это статические библиотеки (вы можете еще услышать название "архивы").
При создании библиотеки линкер берет стопку объектных файлов, проверяет наличие всех реализаций, обещанных на этапе компиляции, и собирает все в один большой бинарник - но это будет еще не исполняемый файл, а что-то вроде полуфабриката.
У исполняемого файла должна быть точка входа - функция main.
У библиотеки ее нет - только набор функций.
То есть как объектный файл, только без "обещанных, но не подставленных" реализаций.
Потом эту библиотеку надо слинковать с объектным файлом, в котором есть main - тогда у вас будет нормальный исполняемый файл, который можно запустить.

Давайте пройдем по шагам.
Посмотрите в папку 00\_simple\_static\_library, разберитесь, что делает код, как его собрать и запустить.
Убедитесь в его работоспособности прежде, чем двигаться дальше.
Makefile писать не обязательно, пока что можно обойтись командами непосредственно компилятору.

Теперь попробуем собрать статическую библиотеку, в которой будут наши функции mul и sum.
Прежде всего, нам нужно скомпилировать файлы mul.cpp и sum.cpp, получив объектные файлы.

```g++ mul.cpp -o mul.o```

```g++ sum.cpp -o sum.o```

Дальше мы собираем эти объектные файлы в библиотеку командой ```ar```.

```ar -q libarithmetic.a mul.o sum.o```

- ```ar``` - это стандартная утилита для создания библиотек. Полный список возможностей, как обычно, смотреть через ```ar -h```, ```ar --help``` или ```man ar```.  *Так же, как и у cowsay - это все стандартное.*
- ```-q``` - флаг, который говорит добавить в библиотеку объектные файлы (с этим можно поэкспериментировать).
- ```libarithmetic.a``` - название библиотеки.
- ```mul.o sum.o``` - файлы, которые мы хотим добавить.

Теперь, когда у нас есть библиотека, мы можем собрать с ней исполняемый файл.
```g++ -o main main.cpp libarithmetic.a```
Ничего особо умного, на самом деле.
Мы перечисляет g++ то, что он должен, в конечном счете, добавить в исполняемый файл. 
В одном списке можно перечислять файлы исходников .cpp/.c, объектные файлы .o, статические библиотеки .a - компилятор по расширению разберется, что с чем делать, и в итоге выдаст один исполняемый файл.

Запустите и удостоверьтесь, что все сработало так же, как и до экспериментов с библиотеками.

А теперь давайте немного про пути.
Вы можете сказать компилятору, где искать заголовочные файлы (хедеры, .h) и библиотеки.
Зайдите в папку 01\_another\_directory\_static\_library.
Там лежит точно такой же main.cpp, как и в 00\_simple\_static\_library, давайте его соберем. 
*Если вы удалили или переименовали библиотеку в 00\_simple\_static\_library, ее нужно собрать заново с правильным названием.*

```g++ main.cpp -o main -I ../00_simple_static_library/ -L ../00_simple_static_library/ -larithm```

- флаг ```-I ../00_simple_static_library/``` пополняет компилятору список директорий, в которых он ищет хедеры. С точки зрения синтаксиса команды, можно писать относительный путь, можно абсолютный - компилятору без разницы, ориентируйтесь на то, чего хотите добиться. А пробел после ```-I``` можно писать, можно и не писать.
- флаг ```-L ../00_simple_static_library/``` пополняет компилятору список директорий, в которых он ищет библиотеки. Синтаксис аналогичен ```-I```. 
- ```-larithm``` а так теперь записывается название библиотеки, чтобы добавленные пути сработали. Такая запись автоматически раскроется - приставит вместо -l правильный путь и приставку lib, а в конец допишет расширение.

Запустите и удостоверьтесь, что все сработало так же, как и до экспериментов с путями.

Можете теперь вернуться в папку 00\_simple\_static\_library и собраться аналогичным образом там:

```g++ main.cpp -o main -L . -larithm```

Чтобы сокращенная запись библиотеки сработала, нам пришлось добавить компилятору путь ```.``` - то есть текущую директорию.

**Статическая библиотека копируется в исполняемый файл.**

### 2. Динамические библиотеки.
Давайте рассмотрим чуть более сложный вариант.
Статические библиотеки копируются в исполняемый файл целиком, что увеличивает его размер на диске и занимаемую память при исполнении.

### 3. Немного кругозора.
Посмотрите на разные проектные файлы. 
Они служат той же цели, что и Makefile - хранят инструкции, по которым исполняемый файл будет генериться из исходников.

Попробуйте найти аналогичные инструкции в файлах проектов - каких-то своих или из папки 00\_project\_files.
Если вы на постоянной основе пользуетесь какой-либо средой разработки, обязательно найдите, как эти инструкции выглядят в оконно-кнопочном интерфейсе.
Пригодится.

Где-то в них написано, какой будет компилятор.
У вас в системе может быть установлено несколько компиляторов - например, gcc, clang, icc (компилятор от Intel) и MSVC (компилятор от Microsoft).
В настройках проекта вы можете выбирать, каким именно компилятором вы хотите компилировать именно этот конкретный проект. 
*Может быть, это вообще будет компилятор не для С++, а для Fortran или Pascal.
Это компилируемые языки, и в них тоже могут быть многофайловые проекты.*
В Makefile вы писали его каждый раз вручную или создавали переменную (например, CXX\_COMPILER).

В файлах проектов могут быть указаны дополнительные пути к библиотекам, статическим и динамическим. 
Попробуйте найти их. 

Какие именно библиотеки подключать - тоже в этих инструкциях. 

И последнее важное, что надо найти - флаги компилятора.
Оптимизация, переключение стандартов, дебаговые символы - все из пункта 0. 
**Вот флаги особенно важно найти в вашей среде разработки.**

### 4. Базовый cmake.

### 5. Подключение библиотек в cmake.

### 5. Рекурсивный cmake.

## Что сдаем

## Материалы
