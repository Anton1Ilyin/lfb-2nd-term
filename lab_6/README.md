# Лабораторная 6
В лабе 4 вы научились писать инструкции для make - утилиты, которая умеет собирать многофайловый проект.
Наверное, вы заметили и то, что с увеличением количества файлов и усложнением зависимостей (которые надо отслеживать руками) писать инструкции становится все сложнее.
А еще бывает, что нужно добавить в проект системные библиотеки - само по себе несложно, но иногда их приходится искать в разных папках системы, и инструкции могут стать совсем громоздкими.

Другая бытовая проблема - у программистов на одном проекте могут оказаться разные среды разработки.
А то и разные операционки.
Лучше, конечно, так не делать, но если уж случилось, хотелось бы иметь инструмент, который одинаковым образом генерирует инструкции для сборки - и Makefile, и файл проекта для Code::Blocks, и для Visual Studio.

Самым распространенным на данный момент решением является **cmake**.
Давайте его и изучим.

## Что делаем

Изучаем cmake.

### 0. Базовый cmake.

Начинаем, как обычно, с базы.
Зайдите в папку 00\_smallest\_cmake\_ever и посмотрите на код, который там лежит.
В hello.cpp лежит простая программа на С++, а в CMakeLists.txt - минимальный набор инструкций, который позволяет эту программу собрать.

Для начала, запустите сам cmake:

```cmake .```
или
```cmake CMakeLists.txt```
, они сработают одинаково, взяв CMakeLists.txt из текущей директории.

Посмотрите на ту кучу файлов, которая появилась у вас в папке.

Для начала, вас интересует Makefile.
Да, это такой же Makefile, как те, которые вы писали на прошлой лабе.
Попробуйте его почитать. 
Обратите внимание на предупреждение в первой же строке - этот Makefile был сгенерирован автоматически.
Из этого следует:

0. Читать глазами будет неудобно. 
1. Если вы полезете руками, можете что-то случайно сломать, и Makefile перестанет работать.
2. Если вы что-то в нем измените, то после нового запуска cmake все изменения сотрутся. В том числе и поломки.

По жизни сам Makefile глазами читают редко, а руками туда не лезут практически никогда.
Если что-то не работает, то чинят в CMakeLists.txt.

Поехали дальше.
Теперь используйте Makefile по назначению:
```make```
или 
```make all```

У вас появится исполняемый файл, запустите его и убедитесь, что он сработал.

А теперь важный момент, который лучше не пропускать. 
Почистите папку от временных файлов cmake.
*Это нужно делать, чтобы ТОЧНО очистить кэш и провести всю сборку заново.*
Да, вам придется делать это руками.
Короткой команды типа clean у cmake нет, а названия не позволяют сделать что-то вроде ```rm CMake*```

Неудобно?
А то. 
Давайте теперь всё сначала, но более цивилизованно.

Все временные файлы cmake принято собирать в отдельную папку, обычно так:

```
mkdir build
cd build
cmake ..
make
./hello
```

Как видите, все временные файлы остаются в папке build, которую, когда надо, можно просто удалить целиком.
И в .gitignore добавлять проще.

Можете покопаться во временных файлах. 
Например, в CMakeFiles/hello.dir лежат промежуточные файлы сборки. 
Если вы вручную запустите дополнительные цели для make (например, ```make hello.s```), он сгенерирует ассемблерный листинг и положит туда же.

### 1. Флаги компилятора.

Вот так вы можете переключать стандарты:
```set(CMAKE_CXX_STANDARD 17)```
(компилятору будет передан флаг ```-std=c++17```)

### 1. Сборка и подключение библиотек в cmake.

### 2. Рекурсивный cmake.

### 3. Сборка простого проекта из исходников.

### 4. Свой простой CMakeLists.txt

### 5. Сборка компилятора из исходников.

### 6. Сборка игры из исходников.

### 7. Сборка и подключение модуля python из исходников.

## Что сдаем
На один плюсик - пункты 3 и 4 обязательно, а еще 5 или 6.
На два плюсика - пункты 5, 6 и 7.

## Материалы

Большой туториал по cmake от авторов: https://cmake.org/cmake/help/latest/guide/tutorial/index.html
