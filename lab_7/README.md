# Лабораторная 6

Еще одна сложная лаба, где у вас может бомбить.
Но - максимально полезная с точки зрения практического применения. 

Итак, вы подошли к концу курса. 
Чему-то вы по дороге научились, к чему-то привыкли, а с чем-то успели смириться. 
По крайней мере, есть надежда, что интерфейс консоли стал для вас более-менее родным, а жонглирование кодом из магии превратилось в оперирование некоторыми сложными, но теоретически разбираемыми на простые детали сущностями.
С ним вам жить еще долгое время, и он вряд ли изменится.
А если вы поняли принципы сборки и подключения библиотек, то и под другими системами сможете работать, и в оконно-кнопочных интерфейсах разных IDE разбираться.
Суть везде одинаковая, и любой пакет можно собрать где угодно.
*Вопрос лишь в том, сколько седых волос вы готовы получить в процессе.*

Итак, давайте собирать разные штуки. 

## Что делаем

Собираем разные штуки.

### 0. Сборка компилятора из исходников.

Мы уже упоминали, что компилятор - это всего лишь еще одна программа.
Когда вы пишете в консоли ```g++ hello.cpp```, вы запускаете исполняемый файл с названием g++, который лежит в системной папке (можете посмотреть, где именно, командой ```which g++```) и передаете ему один аргумент из консоли (строку 'hello.cpp').
*Если в предыдущем предложении что-то непонятно, лучше спросите сразу.*

Давайте скомпилируем себе новый компилятор компилятором.

Начнем с gcc версии 12.2.0.
Скорее всего, "по умолчанию из репозитория" у вас что-то постарее, проверить это можно через ```gcc -v```.
Делается это довольно просто. 

Вот (для Ubuntu так, для других систем - внимательно читайте команды и пишите аналоги, где надо):

```
cd ~
mkdir gcc-12-source
cd gcc-12-source/
wget https://github.com/gcc-mirror/gcc/archive/refs/tags/releases/gcc-12.2.0.tar.gz
tar xzvf gcc-12.2.0.tar.gz
cd gcc-releases-gcc-12.2.0/
contrib/download_prerequisites
sudo apt install flex
mkdir build
cd build/
../configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-12.2.0 --enable-checking=release --enable-languages=c,c++,fortran --disable-multilib --program-suffix=-12.2
make -j 6
sudo make install-strip
```

Это довольно характерный пример набора инструкций, который вы можете встретить в интернете по запросу "g++ compiler from source".
*Или любой аналогичный запрос про установку, сборку, настройку, починку...*
Скорее всего, большую часть команд вы отсюда уже понимаете. 
Это аккуратная организация директорий, скачивание архива, распаковка, сборка и установка в систему.

Давайте немного про команды, которые могут быть непонятны:

```contrib/download_prerequisites``` - внезапно, это запуск бинарника из того архива, который вы скачали и распаковали в папку.
Он за вас устанавливает недостающие пакеты, которые нужны компилятору для сборки... компилятора.
Только flex просят руками поставить (по крайней мере, для Ubuntu).

```../configure``` - аналог cmake, генерирует вам Makefile.
Многие пакеты используют его, и как пользователь вы разницы особо не заметите. 
Запустили одну команду, получили Makefile, дальше как обычно. 
*Если смотреть под капот, то сам configure - это просто баш-скрипт.*
*Можете сами открыть его текстовым редактором, там прям в первой строке будет написано.*
*Помимо базового синтаксиса, там еще используют язык макросов m4.*
*Скорее всего, по жизни вам будет достаточно cmake, но если вдруг придется работать над проектом, в котором уже configure, и коллеги не хотят переезжать - чтож.*
*Если вы поняли, как работает cmake, то и configure по гуглу освоите.*

Давайте немного про флаги, которые мы передаем в configure.
Это один из тех моментов, ради которого люди вообще связываются со сборкой компилятора из исходников - вы можете в очень широких пределах настроить себе компилятор.
Полный список здесь - https://gcc.gnu.org/install/configure.html *(о да, в очень широких пределах)*
Большая часть из них нужна при сборке под различные архитектуры. 
Если у вас Intel/AMD, и в ближайшее время вы не планируете что-то писать для мобильников или микроконтроллеров, то они вам и не понадобятся.

Давайте посмотрим, какие флаги советуют включать в этом наборе инструкций (первые три сложно, дальше попроще):

```--build=x86_64-linux-gnu``` - архитектура машины, на который мы сейчас будем собираться;

```--host=x86_64-linux-gnu``` - архитектура машины, на которой должен в итоге работать компилятор (вы можете скомпилировать компилятор на одной машине, скопировать его на другую архивчиком и там уже запускать);

```--target=x86_64-linux-gnu``` - архитектура машины, на которой будет работать то, что накомпилирует новый компилятор.

То есть, еще раз. 
У вас во всем процессе могут участвовать три разных машины с разной архитектурой.
На первой вы старым компилятором (с архитектурой build) компилируете новый (под архитектуру host).
Этот новый вы копируете на машину с архитектурой host и запускаете его, чтобы скомпилировать какой-то код (под архитектуру target).
Получаете исполняемый файл, копируете его на машину с архитектурой target и запускаете.

*Если разобрались - хорошо. Может внезапно пригодиться. Если нет, то просто запомните, что это все для сборки под микроконтроллеры. Понадобится - вернетесь сюда или просто нагуглите.*

```--prefix=/usr/local/gcc-12.2.0``` - указываем системную директорию, куда будем ставить компилятор (в прошлой лабе, когда ставили gmsh, использовали директорию в ~, но компилятор можно поставить и поближе к системе).

```--enable-checking=release``` - включаем внутренние проверки компилятора компилятором (работает, только если вы gcc компилируете с помощью gcc). 
Если что-то не склеилось, пусть лучше выдаст ошибку, будем чинить.
*Будем честны, просто скачаем архив с другой версией...*

```--enable-languages=c,c++,fortran``` - *и вот, мы коварно заставили вас поставить себе фортран.*
Просто включаете те языки, которые вам нужны - из интересного, там есть еще Ada, D и Go.

```--disable-multilib``` - опять же, это про разные архитектуры. Если они не нужны - ставим disable. 

```--program-suffix=-12.2``` - это чтобы все компиляторы (в смысле под ту стопку языков, которую вы написали выше) были с удобным суффиксом и отличались от обычных системных.

И последняя команда:

```sudo make install-strip``` - установка в систему. Отличается от ```sudo make install``` тем, что вычищает из бинарника дебаговые символы и прочие лишние отладочные штуки. 

Итак, можете ставить. 

Когда поставите, для удобства можете прописать новый компилятор в ```~/.bashrc``` - как вы можете помнить, это скрипт, который срабатывает при запуске баша.
Без этого вам придется каждый раз указывать полный путь до бинарника, типа ```/usr/local/gcc-12.2.0/bin/g++-12.2 hello.cpp``` (так жить можно, но зачем).
Прописывать в bashrc вот это (лучше в конец):

```
export PATH=/usr/local/gcc-12.2.0/bin:$PATH
export LD_LIBRARY_PATH=/usr/local/gcc-12.2.0/lib64:$LD_LIBRARY_PATH

# To let CMake know
export CC=/usr/local/gcc-12.2.0/bin/gcc-12.2
export CXX=/usr/local/gcc-12.2.0/bin/g++-12.2
export FC=/usr/local/gcc-12.2.0/bin/gfortran-12.2
```

Как вы видите, мы немного дописали в переменную PATH и создали пару переменных, чтобы было более удобно cmake.

Собственно, все. 
Можно пользоваться.
В папке ```00_XX_standard_fox``` лежат небольшие кусочки кода с cppreference, которые используют новые стандарты. 
Попробуйте сами разобраться с флагами и убедиться, что со старым компилятором они не работают, а с новым работают.
*Ну, если у вас старый компилятор был действительно старым. Если старый компилятор и сам был вполне новым, вау-фактора поменьше, но все равно проверьте его работоспособность.*

*А не забыли перезапустить bash после переписывания bashrc?..*

### . Сборка и подключение модуля python из исходников.

### . Сборка библиотеки на питоне из исходников.

### . Сборка игры из исходников.
